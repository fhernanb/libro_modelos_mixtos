# Paquete **INLA** 

El paquete **INLA** (integrated nested Laplace approximation) se utiliza para hacer inferencia bayesiana aproximada de diversos modelos. Al visitar este [enlace](https://www.r-inla.org/home) se encontrará un gran contenido que le podría servir para conocer más sobre INLA.

## Ejemplo: modelo Poisson con intercepto aleatorio {-}
En este ejemplo vamos a simular $n_i=50$ observaciones para $G=10$ grupos (en total 500 obs) que tengan la estructura mostrada abajo. El objetivo del ejemplo es ilustrar el uso de la función `inla` para estimar los parámetros del modelo.

\begin{align*} 
y_{ij} | b_0 &\sim  Poisson(\mu_{ij}) \\ 
\log(\mu_{ij}) &= 4 - 6 x_{ij} + b_{0i} \\
b_{0} &\sim N(0, \sigma^2_{b0}=4) \\
x_{ij} &\sim U(0, 1)
\end{align*}

El vector de parámetros de este modelo es $\boldsymbol{\Theta}=(\beta_0=4, \beta_1=-6, \sigma^2_{b0}=4)^\top$.

<div style="-moz-box-shadow: 1px 1px 3px 2px #000000;
  -webkit-box-shadow: 1px 1px 3px 2px #000000;
  box-shadow:         1px 1px 3px 2px #000000;">

```{block2, type='rmdexercise'}
Solución.
```

</div>

El código para simular las observaciones se muestra a continuación.

```{r}
ni <- 50
G <- 10
nobs <- ni * G
grupo <- factor(rep(x=1:G, each=ni))
obs <- rep(x=1:ni, times=G)
x <- runif(n=nobs, min=0, max=1)
b0 <- rnorm(n=G, mean=0, sd=sqrt(4)) # Intercepto aleatorio
b0 <- rep(x=b0, each=ni)             # El mismo intercepto aleatorio pero repetido
media <- exp(4 - 6 * x + b0)
y <- rpois(n=nobs, lambda=media)
datos <- data.frame(obs, grupo, b0, x, y)
```

Delia nos va a mostrar cómo estimar los parámetros del modelo ajustado.

```{r eval = FALSE, echo = TRUE}
library(INLA)
fit1 <- inla( )
```

## Ejemplo: modelo Poisson con intercepto y pendiente aleatoria {-}
En este ejemplo vamos a simular $n_i=50$ observaciones para $G=10$ grupos (en total 500 obs) que tengan la estructura mostrada abajo. El objetivo del ejemplo es ilustrar el uso de la función `inla` para estimar los parámetros del modelo.

\begin{align*} 
y_{ij} | b_0, b_1 &\sim Poisson(\mu_{ij}) \\ 
\log(\mu_{ij}) &= 2 - 8 x_{ij} + b_{0i} + b_{1i} x_{ij} \\
\left (
\begin{matrix}
b_{0} \\ b_{1}
\end{matrix} 
\right ) &\sim 
N\left ( \left [ \begin{matrix}
0 \\ 0
\end{matrix} \right ],
\left [ \begin{matrix}
\sigma^2_{b0}=1 & \sigma_{b01}=0.5 \\ 
\sigma_{b01} & \sigma^2_{b1}=1
\end{matrix} \right ]
\right ) \\
x_{ij} &\sim U(0, 1)
\end{align*}

El vector de parámetros de este modelo es $\boldsymbol{\Theta}=(\beta_0=2, \beta_1=-8, \sigma_{b0}^2=1, \sigma_{b1}^2=1, \sigma_{b01}=0.5)^\top$.

<div style="-moz-box-shadow: 1px 1px 3px 2px #000000;
  -webkit-box-shadow: 1px 1px 3px 2px #000000;
  box-shadow:         1px 1px 3px 2px #000000;">

```{block2, type='rmdexercise'}
Solución.
```

</div>

El código para simular las observaciones se muestra a continuación.

```{r}
ni <- 50
G <- 10
nobs <- ni * G
grupo <- factor(rep(x=1:G, each=ni))
obs <- rep(x=1:ni, times=G)
x <- runif(n=nobs, min=0, max=1)

Sigma <- matrix(c(1, 0.5, # Matriz de var-cov
                  0.5, 1), ncol=2, nrow=2)

b <- MASS::mvrnorm(n=G, mu=rep(0, 2), Sigma=Sigma)   # Simulando b0 y b1
b <- apply(b, MARGIN=2, function(c) rep(c, each=ni)) # Replicando
b0 <- as.vector(b[, 1]) # Separando los b0
b1 <- as.vector(b[, 2]) # Separando los b1

media <- exp(2 - 8 * x + b0 + b0 + b1 * x)
y <- rpois(n=nobs, lambda=media)
datos <- data.frame(obs, grupo, b0, b1, x, y)
```

Delia nos va a mostrar cómo estimar los parámetros del modelo ajustado.

```{r eval = FALSE, echo = TRUE}
library(INLA)
fit2 <- inla( )
```

